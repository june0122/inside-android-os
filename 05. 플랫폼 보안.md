# 5장. 플랫폼 보안

<p align = 'center'>
<img width = '500' src = 'https://github.com/june0122/TIL/assets/39554623/b046a883-b983-4505-9a34-6fa404342fd9'>
</p>

## 개요

- 임베디드 플랫폼<sup id = "a1">[1](#f1)</sup>에 보안 기능을 구현하는 것은 매우 난해하다.
- 안드로이드의 보안 인프라는 전체 소프트웨어 스택마다 스며들어 있다.
- 안드로이드 보안 스택은 커널에서 시작해서 그 위로 쌓아 올라간다.
- 5장에서는 안드로이드 스택이 어떻게 구성되어 있고, 새 디바이스에선 어떤 부분이 커스터마이징되는지 살펴본다.

## 보안의 종류

안드로이드와 같은 플랫폼은 보안에 대해서 여러 측면을 고려해야 한다.

- 칩셋: 애플의 M1, M2와 같은 SoC<small>(System on a Chip)</small>가 **올바른 작업을 수행**하는지 어떻게 알 수 있는가?
- 운영: 시스템은 이 **동작이 허용**되는지를 어떻게 알 수 있는가?
- 사용자: 앱과 시스템은 **자신들의 데이터와 동작을 안전하게 보호**하는가?
- 커스터마이징: 앱과 시스템은 가용한 **보안 기능을 어떻게 확장**할 수 있는가?

디바이스를 제조하는 OEM들은 보안 기능을 효과적으로 사용하기 위해
1. 플랫폼 내에서 보안이 **어떻게 처리**되는지를 이해해야 함.
2. 보안 시스템을 **어떻게 사용**해야 하는지도 이해해야 함.

## 자체 검사 부팅<small>(Verified Boot)</small>

<p align = 'center'>
<img width = '500' src = 'https://github.com/june0122/TIL/assets/39554623/9bfc1918-d49a-4062-bec6-42460bd60623'>
</p>

안드로이드 7부터 모든 안드로이드 디바이스는 자체 검사 부팅 기능이 탑재되어야 한다.

- 안드로이드의 자체 검사 부팅
  - ChormeOS에서 사용된 보안 부팅 기술에서 가져옴.
  - 칩셋에 내장된 보안 부트 체인<sup id = "a2">[2](#f2)</sup> + 리눅스 커널의 *dm-verify* 기능
  - 사용 목적: 시스템이 신뢰할 수 있는 커널과 안드로이드 시스템만 실행 가능하도록 보장하기 위해
  
<br>

- 통상 칩셋은 부트 체인이 안전함을 보장하기 위해 공개된 암호화 기술을 사용한다.
  - 칩셋은 디바이스 내 일회용 쓰기 저장소 내에 공개키<small>(인증서, certificates)</small> 세트를 저장한다.
  - 칩셋의 ROM 내에는 신뢰할 수 있는 루트 인증서와 하나 혹은 여러 개의 중간 서명 인증서가 들어 있다.
  - OEM은 자신만의 키/인증서 세트를 생성해서 칩셋 제조사에게(혹은 ROM 내 신뢰할 수 있는 인증서로부터) 서명을 받고 최종적으로 해당 OEM 공개 인증서를 칩셋 내의 일회용 쓰기만 가능한 영역에 굽는다.
  - 이렇게 보안 부트 동작을 영구히 설정하는 최종 단계의 일회용 쓰기 작업을 보통 <b>퓨즈<small>(fuse)</small>를 끊는다</b>라고 표현한다.
  - 칩셋에 따라서 이 작업은 OEM 키/인증서가 기롤할 때 수행하거나 별도의 작업을 통해 이뤄진다.
  - 이 작업을 통해 디바이스의 보안 부트가 활성화되고 부트로더의 실행과 리눅스 커널 실행을 위해서는 서명된 펌웨어/이미지가 디바이스에 탑재되어야 한다.

<br>

- 칩셋의 퓨즈가 끊어지고 OEM의 인증서가 탑재되었다면 ROM은 가장 낮은 단계의 <small>(신뢰하는)</small> 부트로더로 부팅하고 부트체인의 다음 단계에 있는 부트로더를 검증한다.
- 대부분 칩셋의 보안 부트 기능은 애플리케이션 부트로더까지 유효성을 검증한다.
- 이 시점에서 로드하려는 커널이 유효하고 신뢰할 수 있음을 검증할 수 있도록 필요한 지원을 제공하는 것이 OEM의 책임이며, 바로 이 지점이 OEM이 관심을 갖게 되는 부분이다.
- 각 반도체 제조사는 uboot 혹은 사용자 정의 부트로더 같은 서로 다른 애플리케이션 부트로더를 제공할 수 있다.
- 여기서 반도체 제조사의 보안 부트 지원 기능을 활성화할 것이냐 아니면 주어진 부트로더를 확장하여 보안 부트 기능을 적절히 제공할 것이냐는 전적으로 OEM이 결정할 문제다.

<br>

- 부트로더가 암호화된 서명을 사용해 리눅스 커널 검증을 끝낸 후에는 커널이 로드되고 안드로이드 시스템 이미지의 세부 사항 및 이미지의 보안 해시 메타데이터와 함께 커널로 제어권이 넘어간다.
- 안드로이드 8부터 AOSP 내에 안드로이드 자체 검증 부트의 참조 구현 내용이 포함되어 있다.
- 플랫폼 make 파일에 아래와 같이 한 줄을 추가하면 보안 이미지를 빌드하도록 이 기능을 활성화할 수 있다.

#### 안드로이드 자체 검증 부트를 활성화하기 위한 Make 파일 변경

```
BOARD_AVB_ENABLE := true
```

- 위와 같이 하면 빌드 시스템은 부트 이미지와 타깃용 vbmeta.img라는 메타데이터 이미지 파일을 생성
  - 이 안에는 부트 이미지에 대한 해시 데이터와 시스템 이미지에 대한 세부 해시트리, 그리고 커널이 시스템 이미지를 로드하기 위한 *dm-verify*용 부트 명령행 파라미터 세트를 포함하고 있다.
- 제조사가 제공하는 바인더화된 HAL을 제조사 이미지 같은 다른 이미지들도 역시 지원 가능하다.
- 기본 구현 코드는 SHA-256과 AOSP 트리 내의 *external/avb/test/data*에 있는 RSA 4096 비트 키를 사용한다.
- OEM은 **반드시** 이 기본 구현 코드를 재정의하고 사용자 정의 키를 제공해야 한다.
- 아래와 같이 추가로 플랫폼 make 파일의 변수 두 개를 더 정의해서 알고리즘과 키 값을 명시할 수 있다.

#### AVB 서명 키를 명시하기 위한 Make 파일 변경

```
BOARD_AVB_ALGORITHM := SHA512_RSA4096
BOARD_AVB_KEY_PATH := /path/to/rsa_key_4096bits.pem
```

- 부트로더가 시스템 이미지를 검증하기 위해서는 사용된 키 쌍 중 공개키가 제공되어야 한다.
- 참조 구현 코드는 이 데이터를 올바른 형식으로 추출할 수 있는 툴을 포함하고 있다.
- 추가로 참조 구현 코드는 libavb라는 C 라이브러리를 제공하는데, 이 라이브러리를 애플리케이션 부트로더에 통합하면 자체 검증 부트를 지원하기 위해 필요한 기능을 구현할 수 있다.

<br>

- 부트 이미지가 검증되고 나면 커널이 로드되고, 커널은 어떤 이미지가 안정한지를 확인하기 위해 명령행 파라미터를 통해 *dm-verify*를 사용하는 명령을 수행한다.
- 커널에서 실행되는 *dm-verify*는 시스템 이미지가 안전한지를 실시간으로 확인하기 위해 보안 해시 데이터를 지원한다.
- 각 파일 시스템 블록은 해시 트리의 일부로 루트 해시까지 암호화 방식으로 해시 처리된다.
- 루트 해시는 빌드될 때 OEM에 의해 서명된다.
- 실행 중 커널의 *dm-verify* 드라이버는 파일 시스템 블록을 하나 읽어 들일 때마다 트리의 루트 해시까지 보안 해시를 계산한다.
- 이렇게 하면 성능에 악영향을 끼칠 것처럼 들릴 수 있으나 실제로는 데이터를 스토리지에서 읽어 들이는 데 소요되는 I/O 대기 시간과 비교해 심각한 부담을 가중시키지 않는다.
- 이렇게 계산된 해시 데이터는 메타데이터 내의 서명된 해시 데이터와 비교된다.
- 이 둘이 다르다면 파일 시스템은 해킹을 당했거나 손상되었음을 의미한다.
- 이럴 경우 커널은 저수준 파일 시스템 드라이버로부터 I/O 오류를 반환하고 스택 상위로 오류 정보를 전파한다. 다시 말하면, *dm-verify*는 읽기전용 파일 시스템 혹은 해당 디바이스에 탑재된 안드로이드 내에서 변하지 않는 파일 시스템을 검증하는 데만 사용할 수 있다는 의미다!
- 이런 부류에 속하는 안드로이드 파일 시스템으로는 *system, system_ext, product, vendor, odm* 이미지가 있다.

## 운영 보안

- 안드로이드 같은 복잡한 운영체제는 애플리케이션과 다른 종류의 프로세스에 의해 지속적으로 운영된다.
  - 운영 -> 단순히 애플리케이션 내부의 코드를 실행 or 애플리케이션의 요청에 기반해 어떤 액션을 수행
  - 어느 쪽이든 시스템은 어떤 동작이 허용되는지를 관리하고 필요한 제약을 강제한다.

#### 안드로이드의 운영 보안 매커니즘

1. 프로세스 샌드박스 기능
2. 안드로이드를 위한 SE 리눅스
3. 안드로이드에서 정의 하는 권한 기능

> 이런 매커니즘은 소프트웨어 스택 계층이 명확하게 분리되어 있고, 제일 기저에 구축된 리눅스 커널 때문에 구현이 가능하다.

### 안드로이드 소프트웨어 계층

> 리눅스 커널은 시스템 내에서 가장 기본이 되는 보안 장벽이다.

<p align = 'center'>
<img width = '300' src = 'https://github.com/june0122/TIL/assets/39554623/f36416a7-fead-4b78-84d7-67512cabf34b'>
</p>

- 커널은 기저부의 하드웨어 및 시스템에서 동작하는 모든 프로세스를 통제할 뿐만 아니라 보안 아키텍처의 기본 토대를 제공한다.
  - 기저부에 위치한 하드웨어, 프로세스 스케줄링, 메모리 관리, 그리고 SE 강제를 완전히 통제한다.
- 애플리케이션 코드를 실행하는 ART 또는 Dalvik와 같은 **런타임은 추가적인 보안 기능을 전혀 수행하지 않는다.**
- 모든 사용자 공간 프로세스는 그것이 서드파티 애플리케이션<small>(APK)</small>이든 아니면 네이티브 코드를 실행하는 데몬이든 완전히 동일한 보안 장벽의 통제를 받는다.
  - 단지 코드가 C/C++로 작성되었다는 이유 혹은 NDK를 이용해서 컴파일 되었다는 이유만으로 그런 사용자 공간 프로세스가 시스템 보안 장벽을 마음대로 우회할 수 있는 것은 안니다.
  - 기본적으로 시스템 내의 각 프로세스는 자신이 속한 작은 세상 속으로 **샌드박스**화 된다.<sup id = "a3">[3](#f3)</sup>

### 프로세스 샌드박스

- 다른 리눅스 기반 시스템처럼 안드로이드는 애플리케이션을 각자의 프로세스 안으로 로드하고 그 프로세스 내부에서 실행한다.
  - 각 프로세스는 자기 자신의 명확한 메모리 공간이 있어 **메모리 상의 다른 프로세스로부터 격리**될 수 있다.
  - 각 프로세스는 기본적으로 소유자 프로세스만 접근이 허용되는 파일 시스템 일부를 할당 받는다. 파일 시스템의 다른 영역은 접근이 제한된다.
  - 프로세스는 실제로 자기 자신의 메모리 공간과 파일 공간 **외부의 많은 것과 상호작용할 수 없다.**
- 애플리케이션 프로세스는 디바이스를 활성화 상태로 유지하거나 커널 디바이스 핸들에 접근하는 등의 일을 할 수 없다.
  - 그러므로 애플리케이션은 샌드박스화 되어 있다.
  - 표면적으로 이런 접근 방식은 빈틈이 없어 보이지만 이것조차 충분하지 않기 때문에 몇 가지 모호한 세부 기능이 시스템 내의 다양한 컴포넌트를 격리시키도록 작동한다.

#### 안드로이드의 프로세스 샌드박스

<p align = 'center'>
<img width = '400' src = 'https://github.com/june0122/TIL/assets/39554623/1d9b49e0-e970-4644-a015-d436d403f7fd'>
</p>

- 전통적인 리눅스 UID/GID 개념과 달리, 안드로이드는 UID를 시스템을 사용하는 특정 사용자를 식별하는 용도가 아니라 안드로이드 내의 각 애플리케이션이 설치될 때 해당 애플리케이션에 UID를 할당한다.
  - 다중 사용자 프로필을 사용해서 안드로이드 시스템을 구동할 때는 각 앱 ID와 특정 사용자 ID를 합한 고유한 UID를 각 앱에 할당한다.
- 데몬/서비스와 같은 시스템 프로세스 역시 비슷하게 빌드 과정에서 특별한 UID가 지정되는 식으로 처리된다.
  - UID와 GID 지정을 통해 실행되는 프로세스가 서로 격리
  - 이런 개념을 적용하지 않으면 각 프로세스는 일부 임베디드 RTOS<small>(Real-Time Operating System)</small>에서 하듯이 다른 프로세스의 리소스를 실제로 변경하거나 조작할 수 있게 된다.

#### DAC

- 프로세스 샌드박스와 UID/GID 사용은 매우 성긴 정밀도의 시스템 제어 기능을 제공 -> 선택적 접근 제어<small>(DAC, Discretionary Access Control)</small>
  - 원래 안드로이드는 앱과 시스템 프로세스의 격리를 위해 DAC 기법만을 사용했었으나, 안드로이드의 기능이 확장되면서 더 이상 앱 상호 간 및 시스템 간의 보호에 충분하지 않게 되었다.
  - 해킹 당한 System Server 프로세스는 슈퍼유저 권한을 갖고 있으므로 잠재적으로 전체 시스템을 손상시킬 수 있다.

#### MAC

- 강제 접근 제어<small>(MAC, Mandatory Access Control)</small>이라 불리는 다른 접근 방법으로 이 문제를 완화할 수 있다.
  - MAC은 슈퍼유저 권한으로 실행되는 시스템 프로세스를 포함한 **모든 프로세스를 제한할 수 있다.**
  - MAC을 적용하면 시스템 내에 일관성 있는 시스템 차원의 정책을 수립할 수 있다.
  - 프로세스는 메모리 내 및 파일 시스템을 통해서 샌드박스 처리될 뿐만 아니라 시스템 내에서의 다른 세밀한 수준의 동작을 수행하는 것에서도 추가로 제한을 받는다.

### 안드로이드용 SE 리눅스

> 보안 강화<small>(Security Enhanced)</small> 리눅스, SE 리눅스

- SE 리눅스는 수정된 리눅스 커널과 SE 동작을 관리하고 제어하기 위한 사용자 공간 툴의 조합으로 구성된다.
- 전통적인 리눅스의 DAC 지원과 마찬가지로 MAC 강제도 리눅스 커널이 처리한다.
  - SE 리눅스는 전통적인 DAC이 사용했던 단순한 <b>소유자 중심<small>(owner-oriented)</small></b> 매커니즘을 넘어서 프로세스 기능을 제한할 수 있도록 보안 기능이 OS에 의해 처리되는 방식을 정밀하게 개선했다.
  - MAC 기능이 활성화되면 특정 정책이 위반되었을 때 커널이 무엇을 할 수 있는지를 명시한 정책 세트가 주어진다.

#### SE 활성화 시, 커널의 2가지 동작 모드

1. 허용<small>(permissive)</small> 모드 : 정책 위반 발생하면 커널은 감시 로그를 출력하지만 해당 동작이 계속 수행하도록 허용
2. 강제<small>(enforcing)</small> 모드 : 정책 위반 발생하면 로그도 출력하고 동시에 해당 동작을 중단

#### 안드로이드에 SE 리눅스를 적용함으로써 달성에 도움이 된 OS 보안 목표

- 시스템 앱/실행파일이라고 할지라도 일반적으로 접근이 허용되지 않는 리소스에 대한 접근을 허용할 수 있는 권한 상승 기능의 차단
- 프로세스 간 데이터 유출 차단
- 보안 우회 기술 차단

> 이상적인 아키텍처는 아마도 분산된, 최소 권한의, 분리된 위험의, 그리고 각 상황에 맞는 SE 정책을 보유한 설계일 것이다.

- 이런 이유로 SE 정책과 시스템 구조가 치명적인 동작을 더 잘 제한할 수 있도록 진화해왔고, 이 아이디어가 바인더화된 HAL과 연관이 된다.
  - 안드로이드 8부터 이 바인더화된 HAL 덕분에 OEM과 제조사 컴포넌트의 격리와 제한 기능이 크게 개선되었다.

### 안드로이드 권한

- 안드로이드의 권한 시스템은 MAC 및 프로세스 샌드박스 시스템 위에서 구축되어 더욱 세밀한 통제 기능을 제공한다.

#### 권한의 4가지 보호 수준

- normal: 하드웨어, 디바이스 전용 기능, 사용자의 개인 데이터를 노출하지 않는 기능을 보호함
- dangerous: 하드웨어, 디바이스 전용 기능, 사용자의 개인 데이터를 노출할 가능성이 있는 기능을 보호함
- signature: 동일한 인증서로 서명한 패키지에서만 사용 가능함
- signatureOrSystem: signature와 유사하나 시스템 앱에서도 사용 가능함

> 권한은 코드 구현에서 결정한 의미를 나타내는 단순한 문자열일 뿐이다.

- 어떤 경우에는 권한이 안드로이드에 의해 정의되며 이 권한은 특정 SE 컨텍스트 혹은 GID와 연결되기도 하는데, 규칙보다 예외가 더 많다.
- 게다가 권한 이름 관련해서는 중앙에서 통제하지도 않고 준수해야 하는 형식도 없다.
  - 이것 때문에 권한 명칭 충돌이 생길 가능성이 잠재해 있으며 충돌이 발생하면 먼저 온 것에 우선권을 주는 식의 시스템으로 대부분 해결한다.
  - 최선의 방법은 새로운 권한 정의할 때 충돌 가능성을 최소화하기 위해 네임스페이스를 지정하는 것이다.
    - `PROXIMITY_ACCESS`라는 이름보단 `com.acme.permisson.PROXIMITY_ACCESS`라는 이름을 사용하는 것이 낫다.

#### 권한 강제 방식

> 안드로이드에서 서로 다른 종류의 보호를 제공하기 위해서 아래의 2가지 방식이 모두 필요하다.

1. 자동 강제<small>(automatic enforcement)</small>
2. 수동 강제<small>(manual enforcement)</small>

------------------------


<b id = "f1"><sup>임베디드 플랫폼</sup></b>  [ ↩](#a1)

- 임베디드 시스템<small>(Embedded Platform)</small>은 특정 목적을 수행하기 위해 최적화된 시스템이고, 반대 개념으로는 범용 시스템<small>(General Purpose System)</small>을 사용한다.
- 주로 **제한된 리소스**를 갖고 있는 특정한 응용 분야나 장치를 위한 **하드웨어와 소프트웨어의 통합된 시스템**을 가리킴.
- 일반적으로 특정 하드웨어 아키텍처와 그 위에서 동작하는 특수한 운영 체제 및 소프트웨어 스택으로 구성되어 있다.

<b id = "f2"><sup>[부트 체인](https://blog.quarkslab.com/analysis-of-qualcomm-secure-boot-chains.html)</sup></b>  [ ↩](#a2)

> 모든 스테이지가 로드되고, 인증된 후에야 다음 단계가 실행되는 체인


<p align = 'center'>
<img width = '150' src = 'https://github.com/june0122/TIL/assets/39554623/28ff7c68-1d6e-48cf-9563-0f8495e88237'>
</p>

- 인증의 예시: 공개키 암호화 (RSA 암호화)
- 첫 번째 단계인 부트롬은 대부분 CPU [다이](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%9D%B4_(%EC%A7%91%EC%A0%81_%ED%9A%8C%EB%A1%9C))에 저장되기 때문에 암묵적으로 신뢰된다.
  - 이를 수정하는 것은 이론적으론 가능할 수 있지만 확장성이 떨어진다.
  - 그 결과 신뢰할 수 있는 구성 요소로 이루어진 체인이 생성된다.

<b id = "f3"><sup>프로세스의 샌드박스화</sup></b>  [ ↩](#a3)

> 스레드는 '실행'의 단위이고 **프로세스는 독자적인 메모리 '공간'** 혹은 특별한 권한을 부여하는 '자격'의 요소라 보는게 더 정확하다. - *책의 70p 하단 주석*

<p align = 'center'>
<img height = '200' src = 'https://github.com/june0122/TIL/assets/39554623/36f6719d-3c15-4fcc-a7cf-ebf4ed5689cb'>
<img height = '200' src = 'https://github.com/june0122/TIL/assets/39554623/ca872f57-a81c-4114-9067-88af4e97b8af'>
</p>

- 샌드박스 : 보호된 영역 내에서 프로그램을 동작시키는 것으로, 외부 요인에 의해 악영향이 미치는 것을 방지하는 보안 모델.