# 5장. 플랫폼 보안

<p align = 'center'>
<img width = '500' src = 'https://github.com/june0122/TIL/assets/39554623/b046a883-b983-4505-9a34-6fa404342fd9'>
</p>

## 개요

- 임베디드 플랫폼<sup id = "a1">[1](#f1)</sup>에 보안 기능을 구현하는 것은 매우 난해하다.
- 안드로이드의 보안 인프라는 전체 소프트웨어 스택마다 스며들어 있다.
- 안드로이드 보안 스택은 커널에서 시작해서 그 위로 쌓아 올라간다.
- 5장에서는 안드로이드 스택이 어떻게 구성되어 있고, 새 디바이스에선 어떤 부분이 커스터마이징되는지 살펴본다.

## 보안의 종류

안드로이드와 같은 플랫폼은 보안에 대해서 여러 측면을 고려해야 한다.

- 칩셋: 애플의 M1, M2와 같은 SoC<small>(System on a Chip)</small>가 **올바른 작업을 수행**하는지 어떻게 알 수 있는가?
- 운영: 시스템은 이 **동작이 허용**되는지를 어떻게 알 수 있는가?
- 사용자: 앱과 시스템은 **자신들의 데이터와 동작을 안전하게 보호**하는가?
- 커스터마이징: 앱과 시스템은 가용한 **보안 기능을 어떻게 확장**할 수 있는가?

디바이스를 제조하는 OEM들은 보안 기능을 효과적으로 사용하기 위해
1. 플랫폼 내에서 보안이 **어떻게 처리**되는지를 이해해야 함.
2. 보안 시스템을 **어떻게 사용**해야 하는지도 이해해야 함.

## 자체 검사 부팅<small>(Verified Boot)</small>

<p align = 'center'>
<img width = '500' src = 'https://github.com/june0122/TIL/assets/39554623/9bfc1918-d49a-4062-bec6-42460bd60623'>
</p>

안드로이드 7부터 모든 안드로이드 디바이스는 자체 검사 부팅 기능이 탑재되어야 한다.

- 안드로이드의 자체 검사 부팅
  - ChormeOS에서 사용된 보안 부팅 기술에서 가져옴.
  - 칩셋에 내장된 보안 부트 체인<sup id = "a2">[2](#f2)</sup> + 리눅스 커널의 *dm-verify* 기능
  - 사용 목적: 시스템이 신뢰할 수 있는 커널과 안드로이드 시스템만 실행 가능하도록 보장하기 위해
<br>
- 통상 칩셋은 부트 체인이 안전함을 보장하기 위해 공개된 암호화 기술을 사용한다.
  - 칩셋은 디바이스 내 일회용 쓰기 저장소 내에 공개키<small>(인증서, certificates)</small> 세트를 저장한다.
  - 칩셋의 ROM 내에는 신뢰할 수 있는 루트 인증서와 하나 혹은 여러 개의 중간 서명 인증서가 들어 있다.
  - OEM은 자신만의 키/인증서 세트를 생성해서 칩셋 제조사에게(혹은 ROM 내 신뢰할 수 있는 인증서로부터) 서명을 받고 최종적으로 해당 OEM 공개 인증서를 칩셋 내의 일회용 쓰기만 가능한 영역에 굽는다.
  - 이렇게 보안 부트 동작을 영구히 설정하는 최종 단계의 일회용 쓰기 작업을 보통 <b>퓨즈<small>(fuse)</small>를 끊는다</b>라고 표현한다.
  - 칩셋에 따라서 이 작업은 OEM 키/인증서가 기롤할 때 수행하거나 별도의 작업을 통해 이뤄진다.
  - 이 작업을 통해 디바이스의 보안 부트가 활성화되고 부트로더의 실행과 리눅스 커널 실행을 위해서는 서명된 펌웨어/이미지가 디바이스에 탑재되어야 한다.

<br>

- 칩셋의 퓨즈가 끊어지고 OEM의 인증서가 탑재되었다면 ROM은 가장 낮은 단계의 <small>(신뢰하는)</small> 부트로더로 부팅하고 부트체인의 다음 단계에 있는 부트로더를 검증한다.
- 대부분 칩셋의 보안 부트 기능은 애플리케이션 부트로더까지 유효성을 검증한다.
- 이 시점에서 로드하려는 커널이 유효하고 신뢰할 수 있음을 검증할 수 있도록 필요한 지원을 제공하는 것이 OEM의 책임이며, 바로 이 지점이 OEM이 관심을 갖게 되는 부분이다.
- 각 반도체 제조사는 uboot 혹은 사용자 정의 부트로더 같은 서로 다른 애플리케이션 부트로더를 제공할 수 있다.
- 여기서 반도체 제조사의 보안 부트 지원 기능을 활성화할 것이냐 아니면 주어진 부트로더를 확장하여 보안 부트 기능을 적절히 제공할 것이냐는 전적으로 OEM이 결정할 문제다.

<br>

- 부트로더가 암호화된 서명을 사용해 리눅스 커널 검증을 끝낸 후에는 커널이 로드되고 안드로이드 시스템 이미지의 세부 사항 및 이미지의 보안 해시 메타데이터와 함께 커널로 제어권이 넘어간다.
- 안드로이드 8부터 AOSP 내에 안드로이드 자체 검증 부트의 참조 구현 내용이 포함되어 있다.
- 플랫폼 make 파일에 아래와 같이 한 줄을 추가하면 보안 이미지를 빌드하도록 이 기능을 활성화할 수 있다.

#### 안드로이드 자체 검증 부트를 활성화하기 위한 Make 파일 변경

```
BOARD_AVB_ENABLE := true
```

- 위와 같이 하면 빌드 시스템은 부트 이미지와 타깃용 vbmeta.img라는 메타데이터 이미지 파일을 생성
  - 이 안에는 부트 이미지에 대한 해시 데이터와 시스템 이미지에 대한 세부 해시트리, 그리고 커널이 시스템 이미지를 로드하기 위한 *dm-verify*용 부트 명령행 파라미터 세트를 포함하고 있다.
- 제조사가 제공하는 바인더화된 HAL을 제조사 이미지 같은 다른 이미지들도 역시 지원 가능하다.
- 기본 구현 코드는 SHA-256과 AOSP 트리 내의 *external/avb/test/data*에 있는 RSA 4096 비트 키를 사용한다.
- OEM은 **반드시** 이 기본 구현 코드를 재정의하고 사용자 정의 키를 제공해야 한다.
- 아래와 같이 추가로 플랫폼 make 파일의 변수 두 개를 더 정의해서 알고리즘과 키 값을 명시할 수 있다.

#### AVB 서명 키를 명시하기 위한 Make 파일 변경

```
BOARD_AVB_ALGORITHM := SHA512_RSA4096
BOARD_AVB_KEY_PATH := /path/to/rsa_key_4096bits.pem
```

- 부트로더가 시스템 이미지를 검증하기 위해서는 사용된 키 쌍 중 공개키가 제공되어야 한다.
- 참조 구현 코드는 이 데이터를 올바른 형식으로 추출할 수 있는 툴을 포함하고 있다.
- 추가로 참조 구현 코드는 libavb라는 C 라이브러리를 제공하는데, 이 라이브러리를 애플리케이션 부트로더에 통합하면 자체 검증 부트를 지원하기 위해 필요한 기능을 구현할 수 있다.

<br>

- 부트 이미지가 검증되고 나면 커널이 로드되고, 커널은 어떤 이미지가 안정한지를 확인하기 위해 명령행 파라미터를 통해 *dm-verify*를 사용하는 명령을 수행한다.
- 커널에서 실행되는 *dm-verify*는 시스템 이미지가 안전한지를 실시간으로 확인하기 위해 보안 해시 데이터를 지원한다.
- 각 파일 시스템 블록은 해시 트리의 일부로 루트 해시까지 암호화 방식으로 해시 처리된다.
- 루트 해시는 빌드될 때 OEM에 의해 서명된다.
- 실행 중 커널의 *dm-verify* 드라이버는 파일 시스템 블록을 하나 읽어 들일 때마다 트리의 루트 해시까지 보안 해시를 계산한다.
- 이렇게 하면 성능에 악영향을 끼칠 것처럼 들릴 수 있으나 실제로는 데이터를 스토리지에서 읽어 들이는 데 소요되는 I/O 대기 시간과 비교해 심각한 부담을 가중시키지 않는다.
- 이렇게 계산된 해시 데이터는 메타데이터 내의 서명된 해시 데이터와 비교된다.
- 이 둘이 다르다면 파일 시스템은 해킹을 당했거나 손상되었음을 의미한다.
- 이럴 경우 커널은 저수준 파일 시스템 드라이버로부터 I/O 오류를 반환하고 스택 상위로 오류 정보를 전파한다. 다시 말하면, *dm-verify*는 읽기전용 파일 시스템 혹은 해당 디바이스에 탑재된 안드로이드 내에서 변하지 않는 파일 시스템을 검증하는 데만 사용할 수 있다는 의미다!
- 이런 부류에 속하는 안드로이드 파일 시스템으로는 *system, system_ext, product, vendor, odm* 이미지가 있다.

------------------------


<b id = "f1"><sup>임베디드 플랫폼</sup></b>  [ ↩](#a1)

- 임베디드 시스템<small>(Embedded Platform)</small>은 특정 목적을 수행하기 위해 최적화된 시스템이고, 반대 개념으로는 범용 시스템<small>(General Purpose System)</small>을 사용한다.
- 주로 **제한된 리소스**를 갖고 있는 특정한 응용 분야나 장치를 위한 **하드웨어와 소프트웨어의 통합된 시스템**을 가리킴.
- 일반적으로 특정 하드웨어 아키텍처와 그 위에서 동작하는 특수한 운영 체제 및 소프트웨어 스택으로 구성되어 있다.

<b id = "f2"><sup>[부트 체인](https://blog.quarkslab.com/analysis-of-qualcomm-secure-boot-chains.html)</sup></b>  [ ↩](#a2)

> 모든 스테이지가 로드되고, 인증된 후에야 다음 단계가 실행되는 체인

- 인증의 예시: 공개키 암호화 (RSA 암호화)
- 첫 번째 단계인 부트롬은 대부분 CPU [다이](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%9D%B4_(%EC%A7%91%EC%A0%81_%ED%9A%8C%EB%A1%9C))에 저장되기 때문에 암묵적으로 신뢰된다.
  - 이를 수정하는 것은 이론적으론 가능할 수 있지만 확장성이 떨어진다.
  - 그 결과 신뢰할 수 있는 구성 요소로 이루어진 체인이 생성된다.

<p align = 'center'>
<img width = '150' src = 'https://github.com/june0122/TIL/assets/39554623/28ff7c68-1d6e-48cf-9563-0f8495e88237'>
</p>


